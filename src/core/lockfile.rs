//
//  Copyright (C) 2022-2024  Chase Ruskin
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

use crate::core::ip::Ip;
use crate::core::manifest::FromFile;
use crate::core::manifest::IpName;
use crate::core::source::Source;
use crate::core::uuid::Uuid;
use crate::core::{catalog::CacheSlot, ip::IpSpec};
use crate::core::{
    pkgid::PkgPart,
    version::{self, AnyVersion, Version},
};
use crate::util::anyerror::AnyError;
use crate::util::anyerror::Fault;
use crate::util::sha256::Sha256Hash;
use colored::Colorize;
use serde_derive::{Deserialize, Serialize};
use std::error::Error;
use std::fmt::Display;
use std::{path::PathBuf, str::FromStr};

pub const IP_LOCK_FILE: &str = "Orbit.lock";

const LOCK_VERSION: usize = 1;
const LOCK_COMMENT: &str =
    "# This file is automatically @generated by Orbit.\n# It is not intended for manual editing.";

// define the type to be the most-up-to-date lockfile
pub type LockFile = v1::LockFile;
pub type LockEntry = v1::LockEntry;

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
enum LockVersion {
    V1(v1::LockFile),
}

impl LockVersion {
    /// Casts the out-of-date versions to be the most-up-date data structure
    fn into_latest(self) -> LockFile {
        match self {
            Self::V1(lf) => lf,
        }
    }
}

#[derive(Deserialize)]
struct LockNumber {
    version: usize,
}

impl LockFile {
    pub fn decode(s: &str) -> Result<LockFile, Box<dyn Error>> {
        // grab the version number to determine who to parse
        let data: LockVersion = match toml::from_str::<LockNumber>(&s)?.version {
            // parse for VERSION 1
            1 => LockVersion::V1(
                // parse toml syntax
                match LockFile::from_str(&s) {
                    Ok(r) => r,
                    // enter a blank lock file if failed (do not exit)
                    Err(e) => {
                        println!(
                            "{}: failed to parse {} file: {}",
                            "warning".yellow().bold(),
                            IP_LOCK_FILE,
                            e
                        );
                        v1::LockFile::new()
                    }
                },
            ),
            _ => return Err(AnyError(format!("Unsupported lockfile version")))?,
        };
        Ok(data.into_latest())
    }
}

impl FromFile for LockFile {
    fn from_file(path: &PathBuf) -> Result<Self, Fault> {
        if path.exists() == true {
            // make sure it is a file
            if path.is_file() == false {
                return Err(AnyError(format!("The lockfile must be a file")))?;
            }
            // open file
            let contents = std::fs::read_to_string(&path)?;
            // decode based on version and give the lockfile data
            Self::decode(&contents)
        } else {
            Ok(LockFile::new())
        }
    }
}

// version 1 for the lockfile
pub mod v1 {
    use version::PartialVersion;

    use crate::core::{
        catalog::{Catalog, DownloadSlot},
        ip::PartialIpSpec,
    };

    use super::*;

    #[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
    pub struct LockFile {
        // internal number to determine how to parse the current lockfile
        version: usize,
        ip: Vec<LockEntry>,
    }

    impl FromStr for LockFile {
        type Err = toml::de::Error;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            toml::from_str(&s)
        }
    }

    impl LockFile {
        /// Creates a new empty [LockFile].
        pub fn new() -> Self {
            Self {
                version: LOCK_VERSION,
                ip: Vec::new(),
            }
        }

        pub fn unwrap(self) -> Vec<LockEntry> {
            self.ip
        }

        pub fn wrap(reqs: Vec<LockEntry>) -> Self {
            Self {
                version: LOCK_VERSION,
                ip: reqs,
            }
        }

        /// Checks if a lockfile is empty (does not exist).
        pub fn is_empty(&self) -> bool {
            self.ip.len() == 0
        }

        /// Creates a lockfile from a build list.
        pub fn from_build_list(mut build_list: Vec<&Ip>, root: &Ip) -> Result<Self, Fault> {
            // sort the build list by pkgid and then version
            build_list.sort_by(|&x, &y| {
                match x
                    .get_man()
                    .get_ip()
                    .get_name()
                    .cmp(y.get_man().get_ip().get_name())
                {
                    std::cmp::Ordering::Less => std::cmp::Ordering::Less,
                    std::cmp::Ordering::Equal => x
                        .get_man()
                        .get_ip()
                        .get_version()
                        .cmp(y.get_man().get_ip().get_version()),
                    std::cmp::Ordering::Greater => std::cmp::Ordering::Greater,
                }
            });

            let ip_ref = build_list.iter().map(|f| *f).collect();

            let mut entries = Vec::new();
            for ip in build_list {
                entries.push(LockEntry::create(ip, ip == root, &ip_ref)?);
            }
            Ok(Self {
                version: LOCK_VERSION,
                ip: entries,
            })
        }

        /// Returns an exact match of `target` and `version` from within the lockfile.
        pub fn get(&self, target: &PkgPart, version: &PartialVersion) -> Option<&LockEntry> {
            self.ip
                .iter()
                .find(|&f| &f.name == target && version::is_compatible(version, &f.version))
        }

        /// Returns the current working ip, denoted by not having a checksum with it.
        pub fn get_self_entry(&self, target: &PkgPart) -> Option<&LockEntry> {
            self.ip
                .iter()
                .find(|&f| f.checksum.is_none() && &f.name == target)
        }

        /// Returns the highest compatible version from the lockfile for the given `target`.
        pub fn get_highest(&self, target: &PkgPart, version: &AnyVersion) -> Option<&LockEntry> {
            // collect all versions
            let space: Vec<&Version> = self
                .ip
                .iter()
                .filter_map(|f| {
                    if &f.name == target {
                        Some(&f.version)
                    } else {
                        None
                    }
                })
                .collect();
            match version::get_target_version(&version, &space) {
                Ok(v) => self.ip.iter().find(|f| &f.name == target && f.version == v),
                Err(_) => None,
            }
        }

        /// Given an already generated lockfile, find the highest exact version that would be used
        /// for the provided compatibility version.
        pub fn get_minimum_requires(&self, _target: &PkgPart, _version: &AnyVersion) -> Version {
            todo!()
        }

        pub fn inner(&self) -> &Vec<LockEntry> {
            &self.ip
        }

        /// Writes the [LockFile] data to disk.
        pub fn save_to_disk(&self, dir: &PathBuf) -> Result<(), Box<dyn Error>> {
            // write a file
            std::fs::write(
                dir.join(IP_LOCK_FILE),
                format!("{}\n{}", LOCK_COMMENT, &self.to_string()),
            )?;
            Ok(())
        }

        pub fn keep_dev_dep_entries(&self, target: &Ip, enable: bool) -> Self {
            // find the dev-deps and remove them from the lockfile data
            let entries: Vec<LockEntry> = match enable {
                // install dev-deps anyway
                true => self.inner().clone(),
                // do not install dev-deps (filter them out)
                false => self
                    .inner()
                    .clone()
                    .into_iter()
                    .filter(
                        // check if this entry is a dev dependency
                        |p| match target.get_man().get_dev_deps().get(p.get_name()) {
                            Some(v) => {
                                if version::is_compatible(v.get_version(), p.get_version()) {
                                    false
                                } else {
                                    true
                                }
                            }
                            None => true,
                        },
                    )
                    .collect(),
            };
            LockFile::wrap(entries)
        }
    }

    impl Display for LockFile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", toml::to_string_pretty(&self).unwrap())
        }
    }

    #[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
    pub struct LockEntry {
        name: IpName,
        version: Version,
        uuid: Uuid,
        // @note: `sum` is optional because the root package will have its sum omitted
        checksum: Option<Sha256Hash>,
        #[serde(flatten)]
        source: Option<Source>,
        // @note: `path` is optional and only used if the dependency list uses a local ip
        path: Option<PathBuf>,
        dependencies: Vec<PartialIpSpec>,
    }

    impl LockEntry {
        /// Creates a new [LockEntry].
        fn create(target: &Ip, is_local: bool, others: &Vec<&Ip>) -> Result<Self, Fault> {
            Ok(Self {
                name: target.get_man().get_ip().get_name().clone(),
                version: target.get_man().get_ip().get_version().clone(),
                uuid: target.get_uuid().clone(),
                checksum: if is_local == true || target.get_mapping().is_relative() == true {
                    None
                } else {
                    Some(
                        Ip::read_cache_checksum(target.get_root())
                            .unwrap_or(Ip::compute_checksum(target.get_root())),
                    )
                },
                path: if target.get_mapping().is_relative() {
                    Some(target.get_root().clone())
                } else {
                    None
                },
                source: target.get_man().get_ip().get_source().cloned(),
                dependencies: match target.get_man().get_deps_list(is_local, true).len() {
                    0 => Vec::new(),
                    _ => {
                        let mut result: Vec<PartialIpSpec> = target
                            .get_man()
                            .get_deps_list(is_local, true)
                            .into_iter()
                            .map(|e| {
                                let id = match e.1.as_uuid() {
                                    Some(id) => {
                                        // verify this uuid exists in the build list
                                        if let Some(found_ip) = others.iter().find(|p| p.get_uuid() == id) {
                                            if found_ip.get_man().get_ip().get_name() != e.0 {
                                                panic!("ip with this uuid is not associated with package name {}", e.0)
                                            }
                                        } else {
                                            panic!("no ip found with this uuid")
                                        }
                                        id
                                    },
                                    None => {
                                        // find the ip that matches the name (must only be 1)
                                        let mut found_ip: Option<&Ip> = None;
                                        for other_ip in others {
                                            if other_ip.get_man().get_ip().get_name() == e.0 {
                                                if let Some(already_ip) = found_ip {
                                                    // we came across two ips with the same name but different uuids
                                                    if already_ip.get_uuid() != other_ip.get_uuid() {
                                                        panic!("ip namespace collision {}: please specify the direct dependency's uuid", e.0)
                                                    }
                                                }
                                                found_ip = Some(*other_ip);
                                            }
                                        }
                                        found_ip
                                            .expect("missing an ip from the build list")
                                            .get_uuid()
                                    }
                                };
                                PartialIpSpec::new(
                                    e.0.clone(),
                                    Some(id.clone()),
                                    e.1.get_version().clone(),
                                )
                            })
                            .collect();
                        result.sort_by(|x, y| match x.get_name().cmp(&y.get_name()) {
                            std::cmp::Ordering::Less => std::cmp::Ordering::Less,
                            std::cmp::Ordering::Equal => x.get_version().cmp(&y.get_version()),
                            std::cmp::Ordering::Greater => std::cmp::Ordering::Greater,
                        });
                        result
                    }
                },
            })
        }
    }

    impl From<(&Ip, bool)> for LockEntry {
        fn from(ip: (&Ip, bool)) -> Self {
            let is_working = ip.1;
            let ip = ip.0;
            Self {
                name: ip.get_man().get_ip().get_name().clone(),
                version: ip.get_man().get_ip().get_version().clone(),
                uuid: ip.get_uuid().clone(),
                checksum: if is_working == true || ip.get_mapping().is_relative() == true {
                    None
                } else {
                    Some(
                        Ip::read_cache_checksum(ip.get_root())
                            .unwrap_or(Ip::compute_checksum(ip.get_root())),
                    )
                },
                path: if ip.get_mapping().is_relative() {
                    Some(ip.get_root().clone())
                } else {
                    None
                },
                source: ip.get_man().get_ip().get_source().cloned(),
                dependencies: match ip.get_man().get_deps_list(is_working, true).len() {
                    0 => Vec::new(),
                    _ => {
                        let mut result: Vec<PartialIpSpec> = ip
                            .get_man()
                            .get_deps_list(is_working, true)
                            .into_iter()
                            .map(|e| {
                                PartialIpSpec::new(
                                    e.0.clone(),
                                    match e.1.as_uuid() {
                                        Some(u) => Some(u.clone()),
                                        None => None,
                                    },
                                    e.1.get_version().clone(),
                                )
                            })
                            .collect();
                        result.sort_by(|x, y| match x.get_name().cmp(&y.get_name()) {
                            std::cmp::Ordering::Less => std::cmp::Ordering::Less,
                            std::cmp::Ordering::Equal => x.get_version().cmp(&y.get_version()),
                            std::cmp::Ordering::Greater => std::cmp::Ordering::Greater,
                        });
                        result
                    }
                },
            }
        }
    }

    impl LockEntry {
        /// Performs an equality check against a target entry `other`.
        ///
        /// Ignores the checksum comparison because the target ip should not have its
        /// checksum computed in the .lock file.
        pub fn matches_target<'c>(&self, other: &LockEntry, _catalog: &Catalog<'c>) -> bool {
            self.get_name() == other.get_name()
                && self.get_version() == other.get_version()
                && self.get_uuid() == other.get_uuid()
                && self.get_source() == other.get_source()
                // TODO: have bool to determine if the deps should be hard-matched (such as when ip is local)
                && other.matches_deps_loosely(self.get_deps())
                && self.get_path() == other.get_path()
        }

        /// Only checks uuids if they were provided by both ends.
        pub fn matches_deps_loosely(&self, man: &Vec<PartialIpSpec>) -> bool {
            let deps = &self.dependencies;
            if deps.len() != man.len() {
                return false;
            }
            for d in deps {
                let man_entry = match man.iter().find(|p| p.get_name() == d.get_name()) {
                    Some(found) => found,
                    None => return false,
                };
                // only check uuids if one was provided on the information
                if let Some(mid) = man_entry.as_uuid() {
                    if let Some(lid) = d.as_uuid() {
                        if mid != lid {
                            return false;
                        }
                    }
                }
                // versions are different
                if man_entry.get_version() != d.get_version() {
                    return false;
                }
            }
            true
        }

        /// Verify each dependecy is matched.
        pub fn matches_deps(&self, other: &Vec<PartialIpSpec>, catalog: &Catalog) -> bool {
            let deps = &self.dependencies;
            if deps.len() != other.len() {
                return false;
            }
            for d in deps {
                // find the matching name in the deps
                let read_entry = match other.iter().find(|p| p.get_name() == d.get_name()) {
                    Some(found) => found,
                    // this dependency was not listed in the lockfile's copy
                    None => return false,
                };
                match d.as_uuid() {
                    Some(id) => {
                        // verify the id matches the one in the deps
                        if read_entry.as_uuid().as_ref().unwrap() != id {
                            return false;
                        }
                    }
                    None => {
                        // find the uuid from the catalog
                        match catalog.mappings().get(d.get_name()) {
                            Some(ids) => {
                                match ids.len() {
                                    1 => {
                                        if read_entry.as_uuid().as_ref().unwrap()
                                            != ids.first().unwrap()
                                        {
                                            return false;
                                        }
                                    }
                                    // TODO: formalize into an error (a uuid must be explicitly defined)
                                    _ => {
                                        panic!("a uuid must be explicitly defined in manifest for dependency {}", d.get_name())
                                    }
                                }
                            }
                            // no id exists for this given dependency name
                            None => {
                                return false;
                            }
                        }
                    }
                }
            }
            true
        }

        pub fn is_relative(&self) -> bool {
            self.path.is_some()
        }

        pub fn get_path(&self) -> &Option<PathBuf> {
            &self.path
        }

        pub fn get_deps(&self) -> &Vec<PartialIpSpec> {
            self.dependencies.as_ref()
        }

        pub fn get_sum(&self) -> Option<&Sha256Hash> {
            self.checksum.as_ref()
        }

        pub fn get_uuid(&self) -> &Uuid {
            &self.uuid
        }

        pub fn get_source(&self) -> Option<&Source> {
            self.source.as_ref()
        }

        pub fn get_name(&self) -> &IpName {
            &self.name
        }

        pub fn get_version(&self) -> &Version {
            &self.version
        }

        pub fn to_cache_slot_key(&self) -> CacheSlot {
            CacheSlot::new(self.get_name(), self.get_version(), self.get_sum().unwrap())
        }

        pub fn to_download_slot_key(&self) -> DownloadSlot {
            DownloadSlot::new(self.get_name(), self.get_version(), self.get_uuid())
        }

        pub fn to_ip_spec(&self) -> IpSpec {
            IpSpec::new(self.name.clone(), self.uuid.clone(), self.version.clone())
        }
    }
}

// #[cfg(test)]
// mod test {
// use super::*;

//         #[test]
//         fn to_string() {
//             let lock = LockFile {
//                 version: 1,
//                 ip: vec![
//                     LockEntry {
//                         name: IpName::from_str("lab1").unwrap(),
//                         version: Version::from_str("0.5.0").unwrap(),
//                         uuid: Uuid::nil(),
//                         checksum: None,
//                         path: None,
//                         source: Some(Source::from_str("https://go1.here").unwrap()),
//                         dependencies: vec![
//                             PartialIpSpec::new(
//                                 PkgPart::from_str("lab4").unwrap(),
//                                 None,
//                                 PartialVersion::from_str("0.5.19").unwrap(),
//                             ),
//                             PartialIpSpec::new(
//                                 PkgPart::from_str("lab2").unwrap(),
//                                 None,
//                                 PartialVersion::from_str("1.0.0").unwrap(),
//                             ),
//                         ],
//                     },
//                     LockEntry {
//                         name: IpName::from_str("lab2").unwrap(),
//                         version: Version::from_str("1.0.0").unwrap(),
//                         uuid: Uuid::nil(),
//                         path: None,
//                         checksum: Some(Sha256Hash::new()),
//                         source: Some(Source::from_str("https://go2.here").unwrap()),
//                         dependencies: Vec::new(),
//                     },
//                     LockEntry {
//                         name: IpName::from_str("lab3").unwrap(),
//                         version: Version::from_str("2.3.1").unwrap(),
//                         uuid: Uuid::nil(),
//                         checksum: Some(Sha256Hash::new()),
//                         source: None,
//                         path: None,
//                         dependencies: Vec::new(),
//                     },
//                     LockEntry {
//                         name: IpName::from_str("lab4").unwrap(),
//                         version: Version::from_str("0.5.19").unwrap(),
//                         uuid: Uuid::nil(),
//                         checksum: Some(Sha256Hash::new()),
//                         source: None,
//                         path: None,
//                         dependencies: vec![PartialIpSpec::new(
//                             PkgPart::from_str("lab3").unwrap(),
//                             None,
//                             PartialVersion::from_str("2.3.1").unwrap(),
//                         )],
//                     },
//                 ],
//             };
//             println!("{}", &lock.to_string());
//             assert_eq!(&lock.to_string(), DATA1);
//         }

//         #[test]
//         fn from_str() {
//             let lock = LockFile {
//                 version: 1,
//                 ip: vec![
//                     LockEntry {
//                         name: IpName::from_str("lab1").unwrap(),
//                         version: Version::from_str("0.5.0").unwrap(),
//                         checksum: None,
//                         path: None,
//                         uuid: Uuid::nil(),
//                         source: Some(Source::from_str("https://go1.here").unwrap()),
//                         dependencies: vec![
//                             PartialIpSpec::new(
//                                 PkgPart::from_str("lab4").unwrap(),
//                                 None,
//                                 PartialVersion::from_str("0.5.19").unwrap(),
//                             ),
//                             PartialIpSpec::new(
//                                 PkgPart::from_str("lab2").unwrap(),
//                                 None,
//                                 PartialVersion::from_str("1.0.0").unwrap(),
//                             ),
//                         ],
//                     },
//                     LockEntry {
//                         name: IpName::from_str("lab2").unwrap(),
//                         version: Version::from_str("1.0.0").unwrap(),
//                         uuid: Uuid::nil(),
//                         path: None,
//                         checksum: Some(Sha256Hash::new()),
//                         source: Some(Source::from_str("https://go2.here").unwrap()),
//                         dependencies: Vec::new(),
//                     },
//                     LockEntry {
//                         name: IpName::from_str("lab3").unwrap(),
//                         version: Version::from_str("2.3.1").unwrap(),
//                         uuid: Uuid::nil(),
//                         checksum: Some(Sha256Hash::new()),
//                         source: None,
//                         path: None,
//                         dependencies: Vec::new(),
//                     },
//                     LockEntry {
//                         name: IpName::from_str("lab4").unwrap(),
//                         version: Version::from_str("0.5.19").unwrap(),
//                         uuid: Uuid::nil(),
//                         checksum: Some(Sha256Hash::new()),
//                         source: None,
//                         path: None,
//                         dependencies: vec![PartialIpSpec::new(
//                             PkgPart::from_str("lab3").unwrap(),
//                             None,
//                             PartialVersion::from_str("2.3.1").unwrap(),
//                         )],
//                     },
//                 ],
//             };
//             assert_eq!(&LockFile::from_str(&DATA1).unwrap(), &lock);
//         }

//         const DATA1: &str = r#"version = 1

// [[ip]]
// name = "lab1"
// version = "0.5.0"
// uuid = "0000000000000000000000000"
// url = "https://go1.here"
// dependencies = [
//     "lab4:0.5.19",
//     "lab2:1.0.0",
// ]

// [[ip]]
// name = "lab2"
// version = "1.0.0"
// uuid = "0000000000000000000000000"
// checksum = "0000000000000000000000000000000000000000000000000000000000000000"
// url = "https://go2.here"
// dependencies = []

// [[ip]]
// name = "lab3"
// version = "2.3.1"
// uuid = "0000000000000000000000000"
// checksum = "0000000000000000000000000000000000000000000000000000000000000000"
// dependencies = []

// [[ip]]
// name = "lab4"
// version = "0.5.19"
// uuid = "0000000000000000000000000"
// checksum = "0000000000000000000000000000000000000000000000000000000000000000"
// dependencies = ["lab3:2.3.1"]
// "#;
//     }
// }
